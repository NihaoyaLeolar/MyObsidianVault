>设计模式是软件开发中，一种**经过总结和归纳的、可复用的解决方案**
>它们提供了一种通用的方式来解决特定类型的问题，提高代码的结构和质量。

常见的设计模式包括创建型、结构型和行为型模式。
1. **创建型模式**：关注对象的创建过程，将对象的创建与使用分离，以便更好地管理对象的创建和初始化。
	- eg: **单例模式、工厂模式、抽象工厂模式、建造者模式和原型模式**等。
2. **结构型模式**：关注对象之间的组合和结构，通过组合不同的对象来构建更复杂的结构。
	- eg: **适配器模式、装饰器模式、代理模式、桥接模式、组合模式和外观模式**等。
3. **行为型模式**：关注对象之间的交互和职责分配，通过定义对象之间的通信方式和行为来实现特定的功能。
	- eg: **策略模式、模板方法模式、观察者模式、迭代器模式、责任链模式、命令模式、备忘录模式、状态模式、中介者模式和访问者模式**等。
# 随便聊聊
----
在项目中，我经常使用单例模式来确保只有一个实例存在，避免资源浪费。工厂模式则帮助我将对象的创建与使用分离，提高了代码的灵活性和可扩展性。观察者模式在实现事件驱动的系统中非常有用，它使得对象之间能够松耦合地进行通信。
# 具体的设计模式
---
• 单例模式（Singleton Pattern）：确保一个类只有一个实例存在。
• 工厂模式（Factory Pattern）：定义一个创建对象的接口，但让子类决定实例化哪个类。
• 抽象工厂模式（Abstract Factory Pattern）：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。
• 建造者模式（Builder Pattern）：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。
• 原型模式（Prototype Pattern）：用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。
• 适配器模式（Adapter Pattern）：将一个类的接口转换成客户希望的另外一个接口。
• 装饰器模式（Decorator Pattern）：动态地给一个对象添加一些额外的职责。
• 代理模式（Proxy Pattern）：为其他对象提供一种代理以控制对这个对象的访问。
• 责任链模式（Chain of Responsibility Pattern）：避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有一个对象处理它为止。
• 命令模式（Command Pattern）：将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化，对请求排队或记录请求日志，以及支持可撤销的操作。
• 状态模式（State Pattern）：允许一个对象在其内部状态改变时改变它的行为。
• 观察者模式（Observer Pattern）：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。
• 策略模式（Strategy Pattern）：定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换。
• 模板方法模式（Template Method Pattern）：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。
• 迭代器模式（Iterator Pattern）：提供一种方法顺序访问一个聚合对象中各个元素，而又不需暴露该对象的内部表示。
