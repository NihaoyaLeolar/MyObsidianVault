---
tags:
  - 多线程编程
  - 锁
---
# 三种锁 🔒
----
Synchronized底层实现了三种锁，并且包含了各种优化算法，这些都是对用户不可见的。

以下，以底层设计及使用场景分析的角度，从使用的重量到轻量，解释为什么会有三种锁：
1. [[重量级锁]]：仅考虑大多数多线程情况：**很多线程需要同时访问某对象锁**。如名重量级，需要切换到操作系统的 Monitor(管程) 来实现，可以确保多线程安全访问。
2. [[轻量级锁]]：重量级锁涉及到操作系统的底层锁机制，比如互斥量和信号量，以及线程的上下文切换等。这种锁机制的实现会带来一些性能开销和潜在的性能问题，特别是在高并发场景下。当**线程是错开时间来访问对象锁**，也就不存在竞争，可以使用更轻量化的锁来提升性能。只需要用线程栈中的锁记录 Lock Record 来实现。
3. [[偏向锁]]：若**仅有当前的某一个进程访问轻量级锁**，那么会出现锁的多次锁重入，意味着多次 CAS 检查。于是需要更加轻量化的偏向锁，来简化这种场景。

# 锁膨胀 ———— 竞争就升级锁
---
` 偏向锁 `   --竞争-->   ` 轻量级锁 `  --竞争-->  `重量级锁`
## 出现时机

>如果在尝试加[[轻量级锁]]的过程中，CAS 操作无法成功的一种情况就是：有其它线程为此对象加上了轻量级锁（出现了竞争），这时需要进行锁膨胀，将轻量级锁变为重量级锁。


例如：两个线程同时执行method1，obj的轻量级锁出现竞争
```java
static Object obj = new Object(); 

public static void method1() {
	synchronized(obj) {
		// 同步块
	} 
}
```

当 Thread1 进行轻量级加锁时，Thread0 已经对该对象加了轻量级锁
![[CleanShot 2024-04-01 at 22.58.04@2x.png]]
## 锁膨胀流程
以上，Thread1 加轻量级锁失败，进入锁膨胀流程：
1. Thread1 为 Object 对象加 [[重量级锁]]
2. Thread1 自己进入 Monitor 的 EntryList BLOCKED

![[CleanShot 2024-04-01 at 23.01.46@2x.png]]
3. 当 Thread0 退出同步块解锁时，使用 CAS 将 Mark Word 的值恢复给对象头，失败。这时会进入 [[重量级锁]]的解锁流程

# 一些底层的自动优化
---
应该知道一下概念就行
## 锁消除
JIT及时编译器，在运行时发现多余的锁，就会去掉

## 锁粗化 
对相同对象多次加锁，导致线程发生多次重入，可以使用锁粗化方式来优化，这不同于之前讲的细分锁的粒度。


