在java中，我们分成三种变量来讨论：成员变量、静态变量、局部变量

# 先讨论成员变量与静态变量
----
- 如果他们在不同线程之间发生了共享、且有读写操作（存在临界区），则线程不安全
- 不出现共享与读写的，还是不存在线程安全问题的！

例如，以下代码中，list成员变量就会出现线程安全问题（有可能出现共享的情况，比如同一个对象中，list引用是指向堆中的同一块区域的）
```java
class ThreadUnsafe {
	ArrayList<String> list = new ArrayList<>();

	public void method1(int loopNumber) {
		for (int i = 0; i < loopNumber; i++) {
			//临界区, 会产生竞态条件 
			method2();
			method3();
		}
	}

	private void method2() { 
		list.add("1");  //写
	}
	private void method3() { 
		list.remove(0);  //读
	}
}
```

执行：如果线程2还未add，线程1在remove时就会报错：java.lang.IndexOutOfBoundsException
```java
static final int THREAD_NUMBER = 2; 
static final int LOOP_NUMBER = 200; 

public static void main(String[] args) { 
	ThreadUnsafe test = new ThreadUnsafe();
	for (int i = 0; i < THREAD_NUMBER; i++) {
		new Thread(() -> { 
			test.method1(LOOP_NUMBER); 
		}, "Thread" + i).start();
	}
}
```
![[CleanShot 2024-03-29 at 18.02.05@2x.png|400]]
# 再讨论局部变量
----
一般情况下来说，局部变量是线程安全的。但是**局部变量其引用的对象未必是线程安全**的！
- 如果该对象没有逃离方法的作用域，则它是线程安全的
- 如果该对象逃离了方法的作用域，则它是线程不安全的

本质就是看该局部变量**是否会发生被多个线程共享到**的情况！
## 具体举例分析
### 1. 局部变量，线程安全
以下是在test1方法中，创建了一个局部变量i

🍀 注意，说一个题外话：和[[多线程访问共享资源的线程安全问题]]中的静态变量不同，这里局部变量的自增和自减字节码只有一行！不存在指令交替执行的问题。
```java
public static void test1() {
	int i = 10;  //局部变量
	i++;
}
```
就算有多个线程调用了上面的方法，也不会存在线程安全问题，因为不会出现局部变量i共享的情况。(**在JVM中，栈是线程独享的，方法对应到线程的一个栈帧中**)
![[CleanShot 2024-03-29 at 17.48.55@2x.png|400]]
### 2. 局部变量引用的对象，线程可能安全
通过上面成员变量线程不安全的例子，这里将list改为局部变量。线程安全了！
```java
class ThreadSafe {

	public void method1(int loopNumber) {
		ArrayList<String> list = new ArrayList<>();
		for (int i = 0; i < loopNumber; i++) {
			method2(list);
			method3(list);
		}
	}

	private void method2(ArrayList<String> list) { 
		list.add("1");  //写
	}
	private void method3(ArrayList<String> list) { 
		list.remove(0);  //读
	}
}
```
因为list绝对不会出现共享的情况 ———— 每次调用method1方法就会创建一个新的list对象，他们在堆空间中是不同的对象。且method2/3都是private方法，只有可能被method1调用到，list这个对象肯定不会暴露给其他的线程！
![[CleanShot 2024-03-29 at 18.03.04@2x.png|500]]
### 3. 局部变量引用的对象，线程可能不安全
这里还是接着上一个例子，比如将private方法变成public的（这里代码使用继承来实现例子）
那么这会导致线程不安全，因为list对象不一定是从method1中传入的，可能会暴露给其他的线程独写到list对象。
```java
class ThreadSafeSubClass extends ThreadSafe{
	@Override 
	public void method3(ArrayList<String> list) {
		new Thread(() -> {
			list.remove(0);
		}).start(); 
	}
}
```

这里如果在ThreadSafe父类用final修饰，method3方法，防止它被子类重写，才能确保线程安全问题呀！
```java
public fianl void method3(ArrayList<String> list) {
	 ...
}
```
## java语法保障安全的思考
通过以上例子，也可以感受到之前学一些语法时感受不到的层面。
比如，private和[[final修饰词]]是可以保证到线程安全问题的！
这里就体现了java编程中，需要考虑到的开闭原则中的闭！