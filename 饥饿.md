---
tags:
  - 多线程编程
---
>一个线程由于优先级太低，始终得不到 CPU 调度执行，也不能够结束.

饥饿的情况不易演示，讲读写锁时会涉及饥饿问题

## 在解决[[死锁]]问题时，采用顺序加锁的方案，会产生饥饿
```java
public class TestDeadLock {  
    public static void main(String[] args) {  
        Chopstick c1 = new Chopstick("1");  
        Chopstick c2 = new Chopstick("2");  
        Chopstick c3 = new Chopstick("3");  
        Chopstick c4 = new Chopstick("4");  
        Chopstick c5 = new Chopstick("5");  

		//顺序：c1c2c3c4c5, 每次都按锁对象的顺序来加
        new Philosopher("苏格拉底1", c1, c2).start();  
        new Philosopher("苏格拉底2", c2, c3).start();  
        new Philosopher("苏格拉底3", c3, c4).start();  
        new Philosopher("苏格拉底4", c4, c5).start();  
        new Philosopher("苏格拉底5", c1, c5).start();  
    }  
}
```

输出可以看到，某些线程会高频获取锁，其他线程低频获得锁：
```java
17:04:31.410 [苏格拉底4] DEBUG nihaoya.test.Philosopher - eating...
17:04:31.410 [苏格拉底4] DEBUG nihaoya.test.Philosopher - eating...
17:04:31.410 [苏格拉底3] DEBUG nihaoya.test.Philosopher - eating...
17:04:31.410 [苏格拉底3] DEBUG nihaoya.test.Philosopher - eating...
17:04:31.410 [苏格拉底4] DEBUG nihaoya.test.Philosopher - eating...
17:04:31.410 [苏格拉底4] DEBUG nihaoya.test.Philosopher - eating...
17:04:31.410 [苏格拉底4] DEBUG nihaoya.test.Philosopher - eating...
17:04:31.410 [苏格拉底4] DEBUG nihaoya.test.Philosopher - eating...
17:04:31.410 [苏格拉底4] DEBUG nihaoya.test.Philosopher - eating...
17:04:31.410 [苏格拉底4] DEBUG nihaoya.test.Philosopher - eating...
17:04:31.410 [苏格拉底4] DEBUG nihaoya.test.Philosopher - eating...
17:04:31.410 [苏格拉底3] DEBUG nihaoya.test.Philosopher - eating...
17:04:31.410 [苏格拉底3] DEBUG nihaoya.test.Philosopher - eating...
17:04:31.410 [苏格拉底3] DEBUG nihaoya.test.Philosopher - eating...
17:04:31.410 [苏格拉底3] DEBUG nihaoya.test.Philosopher - eating...
17:04:31.410 [苏格拉底4] DEBUG nihaoya.test.Philosopher - eating...
...
```