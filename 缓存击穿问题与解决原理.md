---
tags:
  - 缓存
---
>缓存击穿问题也叫**热点Key**问题，就是一个被高并发访问并且**缓存重建业务较复杂**的key突然失效了，无数的请求访问会在瞬间给数据库带来巨大的冲击。
# 解决方案
---
### 1. 互斥锁
**锁能实现互斥性，本质就是：在缓存重建的这一段时间内，让并发的线程串行执行/进行等待，从而确保安全**
假设线程过来，只能一个人一个人的来访问数据库，从而避免对于数据库访问压力过大。但这也会影响查询的性能，因为此时会让查询的性能从并行变成了串行，我们可以采用tryLock方法 + double check来解决这样的问题。
![[CleanShot 2024-02-28 at 11.26.58@2x.png|360]]
### 2. 逻辑过期
**思路**：不再设置ttl，而是在数据字段里设置一个value，让数据在redis永久存储，但我们逻辑上来判断是否过期。如果过期了，就开启一个新线程去**异步地更新缓存**，这期间靠锁来判断是否正在更新。如果正在更新来了请求，就**返回缓存中未更新的数据**。
这种方案巧妙在于，异步的构建缓存，缺点在于在构建完缓存之前，返回的都是**脏数据**。
![[CleanShot 2024-02-28 at 11.28.13@2x.png|600]]
### 互斥锁 vs 逻辑过期
- 互斥锁：更看重一致性，可用性较差
- 逻辑过期：更看重可用性，不保证一致性
![[CleanShot 2024-02-28 at 11.32.22@2x.png]]