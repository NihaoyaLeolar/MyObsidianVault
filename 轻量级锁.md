---
tags:
  - 锁
  - 多线程编程
---
这里是 [[Synchronized 锁的具体实现原理]] 之轻量级锁的原理剖析
# 使用场景
---
如果一个对象虽然有多线程要加锁，但加锁的时间是错开的（也就是没有竞争，但依旧要保证安全），那么可以使用轻量级锁来优化。例如：
```java
static final Object obj = new Object(); 
public static void method1() { 
	synchronized(obj) { 
		// 同步块 A 			
		method2(); 
	} 
} 
public static void method2() { 
	synchronized(obj) { 
		// 同步块 B 
	}
}
```

# [[对象头]]中的轻量化锁状态
---
```java
|-------------------------------------------------------|--------------------| 
|                   Mark Word (32 bits)                 |        State       | 
|-------------------------------------------------------|--------------------| 
|                 ptr_to_lock_record:3           |  00  | Lightweight Locked | 
|-------------------------------------------------------|--------------------| 
```
# 实现原理 ———— 锁记录 Lock Record
---
通过在线程的栈中，创建**锁记录(Lock Record)对象**，实现轻量级锁。

## 初始情况
- 线程的栈中，默认含有锁记录对象：
	- 字段1: **本锁记录对象地址 + 00 轻量化锁状态**（提前准备好[[对象头]]中的轻量化状态）
	- 字段2 ———— `Object Reference`: 锁住的对象的引用，初始为空
- 堆中的对象，在[[对象头]]中的 Mark Word 字段：**状态基本信息 + 01 初始状态**
![[CleanShot 2024-04-01 at 18.11.13@2x.png|600]]

## 上锁 🔒
1. 让锁记录中 Object reference 指向锁对象
2. 尝试用 cas 替换：将锁记录中的第一个字段和[[对象头]]中的 Mark Word互换
![[CleanShot 2024-04-01 at 18.17.57@2x.png|600]]
3. cas替换成功，表示由该线程给对象加上了轻量级锁

- Object的[[对象头]]的 Mark Word 被设置为了：**锁记录地址以及00状态**
- Object的[[对象头]]的 Mark Word 中未加锁时的基本信息，被拷贝到了锁记录的第一个字段中
![[CleanShot 2024-04-01 at 18.21.56@2x.png|600]]
4. cas替换失败，说明该对象的 Mark Word 已经是有锁的状况，有两种情况

- 如果是其它线程已经持有了该 Object 的轻量级锁，这时表明有**竞争**，进入**锁膨胀**过程
- 如果是自己执行了 synchronized **锁重入**，那么再在线程的栈内存中添加一条锁记录作为重入的计数
![[CleanShot 2024-04-01 at 18.31.17@2x.png|600]]
## 解锁 🔓 
时机：退出 synchronized 代码块时
1. 如果锁记录的第一个字段为null，表示发生过锁重入过程。这时重置锁记录，表示重入计数减一。
![[CleanShot 2024-04-01 at 18.37.11@2x.png|600]]
2. 如果锁记录的第一个字段不为null，这时使用 CAS 将存在锁记录的第一个字段 Mark Word 值恢复给[[对象头]]（也就是互换回去）。
- 成功，则解锁成功 
- 失败，也就是 Object 的[[对象头]]状态已经不是轻量化状态，说明轻量级锁进行了锁膨胀或已经升级为重量级锁，进入[[重量级锁]](重量级锁)的解锁流程