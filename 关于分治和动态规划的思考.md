---
tags:
  - 算法题
---
## 问题起源
这是科大讯飞提前批第一次的笔试中的一个题
![[CleanShot 2024-07-06 at 18.16.02@2x.png|300]]
#### 我的思考过程
1. **暴力**：每次O(N)，对于N次查询一共需要时间复杂度`O(N^2)`
2. **暴力+历史结果存储**：使用一个二维数组来存储历史结果。但是命中率肯定不会太高，所以没多少优化，只能省去完全重复的问题的情况。最坏情况其实还是每次O(N)，对于N次查询一共需要时间复杂度`O(N^2)`
3. **分治+历史结果存储**：使用一个二维数组来存储历史结果。但是我每次将一个问题分成两段去递归地解决，这样可以增大命中率。可以证明每次的时间复杂度，最坏情况其实还是每次O(N)，对于N次查询一共需要时间复杂度`O(N^2)`
4. **存储AC出现的位置+二分**：提前一次遍历存储下AC出现的位置（如A的下标），这个序列是有序的，然后每次找到L和R之间隔着多少，就能算出来多少个AC。LR的位置使用二分法查找，每次的时间复杂度O(logN)，对于N次查询一共需要时间复杂度`O(NlogN)`

>这里只是记录下思考过程，这个过程对于我理解和引申算法的来龙去脉是十分有必要的，引发了我很多思考。这也是我写这篇笔记的初衷，不是解题，而是我的理解到的零散的一些触发
>当然，如果只针对这个算法题的解法，上面的思路没有什么实际意义。
#### 最佳解法
 提前一次遍历，记录一个数组res[n]，res[i]表示下标i之前的内容AC出现了多少次。那么每次查询，直接使用res[r]-res[l]即可，每次的时间复杂度降低到O(1)，对于N次查询一共需要时间复杂度`O(N）`
 
 其实这里也给我一个启发：**不要机械地去想着用二维数组存储区间结果，可以考虑使用一维数组来存储从0到右区间的结果，然后做减法可以得到区间结果。** 前提是，结果满足`ans[i,j] = ans[0,j] - ans[0,i];`这个思想很好迁移，通法记住！

#### 记录一些触发
一开始想到会不会是dp，太久没接触dp了，有点模糊又不清楚
分治和动态规划都是将一个问题分成子问题去解决，但是还是有一些本质的差别：
- 对于我想到的分治，其实是分成两段，还是三段，从什么地方分，都是对结果没有影响的。这也是分治本身的特点
- 而动态规划一般用来解决最优问题，所以从哪里分成子问题才是关键的选择。并且子问题的结果也要是最优的，才能保证原来问题是最优解