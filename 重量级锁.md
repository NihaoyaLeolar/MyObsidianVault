---
tags:
  - 多线程编程
  - 锁
---
Synchronized应用层面的重量级锁，是通过 **Monitor 管程** 实现的！
>Monitor：操作系统(在java程序中可以理解为JVM)提供的一套东西，底层是用C++实现的类 ———— ObjectMonitor

重量级锁涉及到**操作系统的底层锁机制**，比如互斥量（mutex）和信号量（semaphore），以及线程的上下文切换等。这种锁机制的实现会带来一些性能开销和潜在的性能问题，特别是在高并发场景下。
# 原理
---
>每个 Java 对象都可以关联到一个操作系统中的 Monitor 对象

在执行到 
```js
synchronized(obj) {
	...
}
```

为obj对象加重量级锁时，会将obj[[对象头]]中的 **Mark Word 置为一个 Monitor 对象指针**，状态置为10
## [[对象头]]中的重量级状态
```java
|-------------------------------------------------------|--------------------| 
|                   Mark Word (32 bits)                 |        State       | 
|         ptr_to_heavyweight_monitor:30          |  10  | Heavyweight Locked | 
|-------------------------------------------------------|--------------------| 
```

## Monitor 的结构
![[CleanShot 2024-04-01 at 14.57.56@2x.png]]
- `Owner`：表示锁目前的所有者线程，只能有一个，刚开始 Owner 为 null 
- `EntryList`：当锁已经被占有，其他线程执行 synchronized(obj) 时，就会进入 EntryList ———— **BLOCKED** 状态，等待锁的所有权。其中的竞争是不公平的。
- `WaitSet`：之前获得过锁但条件不满足进入 **WAITING**状态的线程


注意：Waiting 状态和 Blokced 状态都是阻塞的，不占用CPU时间片！

# 流程
-----
## 加锁 🔒
- **时机**：当 Thread2 执行 synchronized(obj)
- 步骤： 
	- 将 obj [[对象头]]在无锁状态下的，存在 Mark word 中的一些基本信息，被拷贝到 Monitor 中
	- 设置 obj [[对象头]]中的重量化状态：Mark word 状态设置为10，内容置为该 Monitor 指针
	- 将 Monitor 的所有者 `Owner` 置为 Thread2

## 放弃锁 等待
当Owner已经持有锁，但发现条件不满足，可以放弃锁的所有权：调用 **Wait 方法**进入 WaitSet，进入 Waiting状态。

进入Waiting状态的线程，会在Owner线程调用notify/notifyAll时唤醒，重新进入EntryList竞争等待。

## 解锁 🔓
 - **时机**：Thread2 执行完同步代码块的内容
 - 步骤：
	 - 将 Monitor 的 `Owner` 置回为 null
	 - 将 obj [[对象头]]中的 Mark word 状态回置为 00，并将基本信息恢复给 Mark word
	 - 唤醒 `EntryList` 中等待的线程来竞争锁（竞争是非公平的）


# 自旋优化
---
当重量级锁出现竞争，线程可以自旋等待锁释放。而不是直接进入 Monitor 的 EntryList 阻塞等待，减少线程上下文切换带来的性能损耗。如果超过自旋时间，还是按照流程依旧阻塞等待！（针对多核cpu才有用）

>**自旋**：一直执行循环让cpu核空转，不断试探锁是否已经释放，等待释放后解除自旋。

例如，自旋成功情况：

![[CleanShot 2024-04-01 at 23.24.57@2x.png]]
例如，自旋失败情况：
![[CleanShot 2024-04-01 at 23.24.35@2x.png]]
#### 注意：
1. 自旋会占用 CPU 时间，单核 CPU 自旋就是浪费，多核 CPU 自旋才能发挥优势。 
2. 在 Java 6 之后自旋锁是自适应的，比如对象刚刚的一次自旋操作成功过，那么认为这次自旋成功的可能性会高，就多自旋几次；反之，就少自旋甚至不自旋，总之，比较智能。 
3. Java 7 之后不能控制是否开启自旋功能

# 从字节码看 Monitor 的存在
---
```java
static final Object lock = new Object(); 
static int counter = 0;

public static void main(String[] args) { 
	synchronized (lock) { 
		counter++; 
	} 
}
```
对应的字节码为：
```java
Code:
	stack=2, locals=3, args_size=1
//加锁
	0: getstatic   #2     // <- lock引用 （synchronized开始）
	3: dup 
	4: astore_1           // lock引用 -> slot 1，方便后面解锁
	5: monitorenter       // 将 lock对象 MarkWord 置为 Monitor 指针
//临界区
	6: getstatic   #3     // <- count
	9: iconst_1           // 准备常数 1
	10: iadd              // +1
	11: putstatic  #3     // -> count
//解锁
	14: aload_1          // <- lock引用
	15: monitorexit      // 将 lock对象 MarkWord 重置, 唤醒 EntryList
	16: goto       24
//处理异常
	19: astore_2         // e -> slot 2
	20: aload_1          // <- lock引用
	21: monitorexit      // 将 lock对象 MarkWord 重置, 唤醒 EntryList
	22: aload_2          // <- slot 2 (e)
	23: athrow           // throw e
//返回
	24: return 
	
	Exception table:
		from  to   target  type 
		 6    16    19     any 
		 19   22    19     any

```