---
tags:
  - 算法题
---

### 03. 数组中重复的数字
[LCR 120. 寻找文件副本](https://leetcode.cn/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/)
- 暴力，时间复杂度O(N^2)，空间复杂度O(1)
- 排序，时间复杂度O(NlogN)，空间复杂度O(1)
- 使用set，时间复杂度O(N)，空间复杂度O(N)
- 改题后，题目表述不准确，容易看不出核心突破点：在一个长度为 n 的数组 documents 里的所有数字都在 0 ~ n-1 的范围内。 此说明含义：如果存在备份，数组元素的**索引**和**值**是**一对多**的关系。
	- 所以思路很容易出来了：我们每次把数字移动到与数字相同的下标位置中，时间复杂度O(N)，空间复杂度O(1)
- 上面会更改原始数组，这里还有一种不更改原始数组也不需要额外空间的方式：二分查找 ———— 将1～n的数字分成两段1～m，m+1～n，如果有重复的，前一段/后一段数字的个数应该不对，会超过m个。然后在这一段里继续分，继续数，缩小区间范围。时间复杂度O(NlogN)，空间复杂度O(1)，但是不会破坏原空间

### 04. 二维数组中的查找
[LCR 121. 寻找目标值 - 二维数组](https://leetcode.cn/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/)
- 这是一个二维度上的二分法，和平时差不多，但是我用的是3/4搜索，并且结束条件有三种（易忽略）。
	- 时间复杂度就是 log 以4/3 为底 MN的对数。
- 书上的方法也可以打开思路：观察到，如果从右上角，往下走，排除的都是比它小的，往左走，排除的都是比它大的！其实逆时针旋转45度，就可以看出这是一个类似于二叉树的形态。那么就可以按照二叉搜索的感觉去查找
	- 时间复杂度 O(M+N)

### 05. 替换空格
[LCR 122. 路径加密](https://leetcode.cn/problems/ti-huan-kong-ge-lcof/)
简单的字符串处理，没有啥特别的
### 06. 从尾到头打印链表 
[LCR 123. 图书整理 I](https://leetcode.cn/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/)
- 模拟：正向遍历存入数组，然后把数组倒过来（可以考虑使用辅助栈，也是一样）
- 反转链表，我直接把链表反转了（肯定不是最优解，为了练习）
- 使用递归（递归本质就是一个栈）写，其实就是先计算链表大小，然后给数组反向填写了，正着写也行。（使用递归都要考虑到递归太深会栈溢出）

### 09. 用两个栈实现队列
[LCR 125. 图书整理 II](https://leetcode.cn/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/)
- 很简单的思路，两个栈：s1为入队栈、s2为出队栈 ———— 入队的数字都压入s1，出队从s2出，如果s2为空，就把s1的都pop出再压入s2。

### 11. 旋转数组的最小数字
[LCR 128. 库存管理 I](https://leetcode.cn/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/)
- **二分** O(logN)：注意这题的理解，对于能找到的区间，应该是左边界>=右边界的，不是的就不查找了。但是可能出现二分出来的两段都满足左边界>=右边界的情况（有很多连续相等的段的特殊情况）。这里注意处理相等的情况，直接右边界-1，再继续查。这可能会让退化到O(N)
- **分治** O(logN)：这次其实是对相等情况处理的不好，就迷迷糊糊换了一种写法，写完发现，这不是分治吗，感觉比上面更好，且好理解。每次都分两段来求最小值，然后两个最小值中再取更小的。那么就会很多种情况两段中有一段可以剪枝的：也就是左端<右端，一定是递增序列，直接返回左端。其他的就继续分治即可。结束条件就是只有一个元素。

### 12. 矩阵中的路径
[LCR 129. 字母迷宫](https://leetcode.cn/problems/ju-zhen-zhong-de-lu-jing-lcof/)
- 好久没写dfs了，主要框架还是记得，但是最重要的一点需要工具：对于visited的标记和去标记时机。容易漏掉标记和去标记，这一点还需要修炼和理解！感觉还有不到位的地方，所以目前也不成形。
- 目前看到还有不使用visited数组标记是否已经走过的情况，可以使用改变当前位置内容为某一永远不可能出现的值，所以之后也不会走入，完事儿后再改变回去！

### 13. 机器人的运动范围
[LCR 130. 衣橱整理](https://leetcode.cn/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/)
- dfs/bfs都可以实现，很简单的。dfs还不需要回溯，因为只需要记录点的个数！
- 主要注意新版本的题意不是很对！
### 18. 删除链表的节点 
[LCR 136. 删除链表的节点](https://leetcode.cn/problems/shan-chu-lian-biao-de-jie-dian-lcof/)
- 直接简单模拟编码实现：从链表头开始顺序查找，找到就删除，没啥问题。编码时可以试试**递归**
- 这里主要注意**链表删除操作的思路**： ...-> A -> B -> C ->... 假设是要删除B
	- 一般我之前的思路：获取到B的上一个节点A，将A指向C（主要到删除头节点的情况）
	- 补充一种思路：将C的val以及next赋值到B上（但这要注意到删除尾节点的情况）

### 20. 表示数值的字符串
[LCR 138. 有效数字](https://leetcode.cn/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/)
- 之前很多次才过，这次一遍过了，代码思路有提升
- 有限状态机的解法看了个一知半解，没有深入

### 21. 调整数组顺序使奇数位于偶数前面
[LCR 139. 训练计划 I](https://leetcode.cn/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/)
- 直接前后双指针一遍遍历即可，记得防止数组越界的情况发生！
- 书上提到了对编程拓展性的考察理解

### 22. 链表中倒数第K个节点
[LCR 140. 训练计划 II](https://leetcode.cn/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/)
- 直接想到了双指针，这种固定距离的单项链表问题，双指针很好用

### 24. 反转链表
[LCR 141. 训练计划 III](https://leetcode.cn/problems/fan-zhuan-lian-biao-lcof/)
- 直接使用迭代写，在06题我就写了，之前2023年8月写的迭代更加简洁点...
- 使用递归写，知道可以用，就是没写出来。需要加强一下对递归的理解和编写思路了！

### 25. 合并两个排序的链表
[LCR 142. 训练计划 IV](https://leetcode.cn/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/)
- 直接模拟，我单拉出了一个getNextNode函数来取节点，很清晰
- 用递归也清晰，应该要直接想到用递归的

### 26. 树的子结构
[LCR 143. 子结构判断](https://leetcode.cn/problems/shu-de-zi-jie-gou-lcof/)
- 分两步：先找到相同节点（**可能有多个**），再对相同节点依次判断是否结构一致！

### 27. 二叉树的镜像
[LCR 144. 翻转二叉树](https://leetcode.cn/problems/er-cha-shu-de-jing-xiang-lcof/)
- 很简单，用递归写即可，2分钟AC

### 28. 对称的二叉树
[LCR 145. 判断对称二叉树](https://leetcode.cn/problems/dui-cheng-de-er-cha-shu-lcof/)
- 可以先翻转左子树，再判断，左子树和右子树是否相同！这个会改变原树结构，且需要两遍递归。
- 直接递归判断，感觉更好

### 29. 顺时针打印矩阵
[LCR 146. 螺旋遍历二维数组](https://leetcode.cn/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/)
- 很简单，用搜索那一套
### 30. 包含min函数的栈
[LCR 147. 最小栈](https://leetcode.cn/problems/bao-han-minhan-shu-de-zhan-lcof/)
- 想法1：主要使用优先队列+栈来实现：
	- push操作：都加入
	- top操作：访问栈顶元素
	- pop操作：出栈，并给对象标记已被删除（在优先队列中逻辑删除）
	- getmin操作：从优先队列访问根节点
- 想法2：使用双栈来实现，两栈保持同等高度
	- 原始栈：输入的原始值入栈，每次入栈同时更新最小栈，压入当前最小值
	- **最小栈**：和原始栈保持相同高度
- 这次算是比之前好点，想到了第二个办法。还有更好的，只使用单栈：**差值栈** ———— 当存入x时，先存入 data = x - min，然后保持更新当前min单值。（**data如果是负数，说明此次压入改变了最小值**）（初值min为最大值）（把min设置成long类型记得）
	- pop：删除栈顶data
		- data>=0，说明插入时没有改变min，这里则无须操作
		- data<0，说明插入时改变了min，所以x就是当前min，回退min=x-data
	- top：拿到栈顶data
		- data>=0，说明插入时没有改变min，返回的数据x=data+min
		- data<0，说明插入时改变了min，返回的数据x=最小值min

>以上这个题可以总结一个结论：**栈在满足基本的O(1)的push和pop操作的同时，是可以实现 O(1) 时间随时取出最小值的！**


### 31. 栈的压入、弹出序列
[LCR 148. 验证图书取出顺序](https://leetcode.cn/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/)
- 就是一个栈的模拟，没啥好说的，主要考验代码实现能力

### 32 - I. 从上到下打印二叉树
[LCR 149. 彩灯装饰记录 I](https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/)
- 没啥好说的，像DFS遍历，使用一个队列

### 32 - II. 分行从上到下打印二叉树
[LCR 150. 彩灯装饰记录 II](https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/)
- 和上面一样，只是可以搞成两个队列来实现。或者使用单队列，但多加一个字段来检测本层是否遍历完。

### 32 - III. 之字形打印二叉树
[LCR 151. 彩灯装饰记录 III](https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/)
- 这里使用一个队列+栈即可。也有的用一个双端队列实现，也是可以，但是要记录每一层的数目来看是否遍历完本层。这些之上，多设计一个flag来看本层是从左往右还是从右往左

### 34. 二叉树中和为某一值的路径
[LCR 153. 二叉树中和为目标值的路径](https://leetcode.cn/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/)
- 很简单的dfs，注意回溯、注意剪枝部分的合理性！
- 然后有一个小错误，对于在函数中传递和生成的List对象，不要直接加入答案中，因为这个引用会一直改变！应该加入改对象的拷贝才对！

### 35. 复杂链表的复制
[LCR 154. 复杂链表的复制](https://leetcode.cn/problems/fu-za-lian-biao-de-fu-zhi-lcof/)
- 先复制val和next，正常写就行，就是普通的链表复制（用递归写很简单）。第一遍复制时建立复制和被复制节点的映射，然后第二遍根据映射表复制random。这个很容易想到，之前也是这么想的，就是第一遍复制时用递归更好！（更清晰的是，直接最开始只复制节点，放到映射表中，然后一次性遍历复制）
- 先将链表double再切割！！！ 💡💡💡

### 36. 二叉搜索树与双向链表
主要是要注意在原有的节点上更改！
- 使用递归，我的想法是左右的逻辑分析下来有不一样的地方，只有最后返回时不一样。然后主函数操作也一样，但是也是最后的返回不一样。但是还是分开写了两个函数，应该有更加简单的方法。虽然通过了，但是，写代码时逻辑有点怪怪的。

## 38. 字符串的排列
[LCR 157. 套餐内商品的排列顺序](https://leetcode.cn/problems/zi-fu-chuan-de-pai-lie-lcof/)
很容易想到回溯，但是还是想的不够快。这种分枝的搜索，一定是回溯啦
- 使用map或者数组+vis记录，都可以，主要是统计字符以及是否还能访问
- 这个题的重点就是如何避免重复。可以回溯完成后，再去重；我没想到的是，也可以在回溯时就避免重复：只要保证重复的字符，只能按顺序进入即可。也就是a0a1b，只能a0a1b不能a1a0b，在a0没有被使用前，不能用a1，这样就能避免重复了
	- 这里直接先对字符数组排序即可，重复的字符都会连一起。每次访问时，要判断前一个是否和本字符一样，也就是出现了重复，若前一个字符没有被使用，那这次也不应该使用。
### 50. 第一个只出现一次的字符
[LCR 169. 招式拆解 II](https://leetcode.cn/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/)
- 暴力，时间复杂度O(N^2)
这里要理解，**由于种类是确定个数，字母26个，字符也就最多256个，都是常数级别的！**所以额外利用空间开辟都是常数级！
- 看到使用哈希表，时间复杂度O(N)，空间复杂度O(1)
- 因为是确定字母26个，那么用桶记录即可，O(N)，空间复杂度O(1)

### 52. 两个链表的第一个公共节点
[LCR 171. 训练计划 V](https://leetcode.cn/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/)
重点：这次理解到了链表的相交，题中的链表相交是指节点都是一样的！不仅仅是数字相同！
- 暴力很简单，时间复杂度O(mn)，空间复杂度O(1)
- 使用空间换时间：时间复杂度O(m+n)、空间复杂度O(m+n)
	- 两个链表同时遍历，用**set**记录，直到插入set时重复。
	- 将两个链表遍历完全，放入**栈**，相当于利用栈**后端对齐**了。然后一个个取出，取到最后一个相同的，即是第一个交点。
- 不使用额外空间：时间复杂度O(m+n)、空间复杂度O(1)
	- 将两个链表分别**连接**，连成ab、ba（可以逻辑上连接，不改变原有结构）（相当于**整体后端对齐**了）。然后同时从头遍历，找到相同的就是第一个交点！没有就没交点，记得判断没有的情况！
		- 多次难以理解，例如，以下两个链表的公共节点是6
			- 12367｜4567
			- 4567｜12367
	- 书上还提到了**快慢指针**的解法：先将两个链表遍历一次计算出两个链表的长度，算出长度差t。然后让快指针先走t步，然后快慢指针再同时出发。这样相当于也**后端对齐**了。

### 53 - I. 在排序数组中查找数字
[LCR 172. 统计目标成绩的出现次数](https://leetcode.cn/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/)
- 这是很明显的二分查找，主要注意总结区间查找约定，以及二分查找可以用递推or递归实现，代码实现返回式很灵活。
	- 注意，在找到数字后如果再像两边遍历，时间复杂度可能会倒退回O(N)。
	- 更好的是应该使用二分找：最左、最右，然后算差值计算个数。时间复杂度O(logN)。
### 53 - II. 0～n-1中缺失的数字
[LCR 173. 点名](https://leetcode.cn/problems/que-shi-de-shu-zi-lcof/)
- 简单的二分，和上面一样，主要是注意总结区间查找的约定，我这里一直使用左闭右开的：`mid = (i + j) / 2` 从而 `[i, j) -> [i, mid) + [mid + 1, j)`，注意因为mid不符合我们每次搜索要把mid排除，所以不用考虑进入死循环的问题，如果不排除，某些情况下就会死循环了。最后，这里搜索的结束条件就是`i = j`，这不是一个合法区间了。
	- 这里的理解见**代码随想录**，他的总结我一下子就悟了这么多年的纠结和死循环写法！

### 54. 二叉搜索树的第 k 大节点
中序遍历的倒序搜索，使用深度优先搜索实现。
有点迷糊，但是一边就写出来了。
还是不够熟练和习惯这种思路的实现，后面需要再熟悉一下！

### 55 - I. 二叉树的深度
[LCR 175. 计算二叉树的深度](https://leetcode.cn/problems/er-cha-shu-de-shen-du-lcof/)
- 很简单的递归就可以实现，一分钟AC
### 55 - II. 平衡二叉树
[LCR 176. 判断是否为平衡二叉树](https://leetcode.cn/problems/ping-heng-er-cha-shu-lcof/)
- 利用上面写好的高度函数，想清楚递归的结束条件以及平衡二叉树的判断条件，即可。但是这样出现了**多次递归调用，有浪费和重复！**
- 解决上面问题！


### 57. 和为s的两个数字
[LCR 179. 查找总价格为目标值的两个商品](https://leetcode.cn/problems/he-wei-sde-liang-ge-shu-zi-lcof/)
- 直接想到**双指针**的方法：先确定初始位置:左指针指向第一个，右指针移动到相加大了（一定要注意有两种情况，如果右指针到最后了，就直接取最后的），然后让左右指针往中间靠。小了就左指针右移，大了就右指针左移。
	- 书上的方法是一致的，只是初始直接把左右指针放在了最左和最右

### 58 - I. 翻转字符串
[LCR 181. 字符串中的单词反转](https://leetcode.cn/problems/fan-zhuan-dan-ci-shun-xu-lcof/)
- 直接从尾到头获取字符串，然后一个个放入stringbuilder中
- 书上的方法：先写一个**反转函数**，然后将字符串反转，然后依次再将每个字符串二次反转

### 58 - II. 左旋转字符串 
[LCR 182. 动态口令](https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/)
- 调用substring然后拼接，很简单的想到
- 看书上说，可以利用I的反转函数，**进行三次反转** 

💡：感觉以上两题，使用反转函数的实现方式更麻烦点。可能对C++更友好，因为Java的字符串不可变！但是可以学学思路。

### 59 - I. 队列的最大值
[LCR 183. 望远镜中最高的海拔](https://leetcode.cn/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/)
- 暴力，时间复杂度O(NK)，空间复杂度O(1)
- 使用大根堆，堆中节点包含val和index。以val为降序出堆，并判断index是否还在范围内。时间复杂度O(NlogN)，空间复杂度O(N)
- 使用一个**单调队列**dq（原队列q外的额外空间）来维护和实现一个队列的快速拿到最大值。这里的滑动窗口，滑动一次，相当于入队一次、出队一次。时间复杂度O(N)，空间复杂度O(K)。对于单调队列，原队列在入队和出队时，进行如下维护（可以发现，在这种逻辑下，dq永远是单调递减的，所以这种双向队列我们叫单调队列）。
	- 入队：将该元素x与dq的队尾比较，比x小的都移除，然后将x加入
	- 出队：在dq中，就出

### 59 - II. 队列的最大值
[LCR 184. 设计自助结算系统](https://leetcode.cn/problems/dui-lie-de-zui-da-zhi-lcof/)
- 没啥好说的的，其实就是第一个问题的子问题，一摸一样。
- 建议先做II再做I才对

### 64. 求 1 + 2 + ... + n
[LCR 189. 设计机械累加器](https://leetcode.cn/problems/qiu-12n-lcof/)
- 

### 67. 把字符串转化成整数 
[LCR 192. 把字符串转换成整数 (atoi)](https://leetcode.cn/problems/ba-zi-fu-chuan-zhuan-huan-cheng-zheng-shu-lcof/)
- 主要是注意考虑特殊情况和边界情况，对于整型越界，可以采除法先倒过来试探

## 68. - I 树中两个节点的最低公共祖先
[LCR 193. 二叉搜索树的最近公共祖先](https://leetcode.cn/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/)
- 从根节点往下找，找到第一个为介于两个节点之间（可以重合）的节点，即为所求
[LCR 194. 二叉树的最近公共祖先](https://leetcode.cn/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/)
- 找到从根节点到两个节点直接的路径（带回溯的dfs），在遍历两个路径，找到第一个分叉口
- 递归也能做，有点难理解，dfs竟然是判断本树是否含有p or q...
