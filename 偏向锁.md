---
tags:
  - 多线程编程
---
Java 6 中引入了偏向锁来对[[Synchronized 锁的具体实现原理]]做进一步优化:
>在第一次使用 [[CAS]]时: 依旧保持 01 状态，但将 biased_lock 置为1，在[[对象头]]的 Mark Word中保存线程ID。

之后在访问到对象带有偏向锁时，如果这个线程 ID 是自己的就表示没有竞争，不用重新 CAS。以后只要不发生竞争，这个对象就归该线程所有。

# 偏向锁 VS. 轻量级锁 
---
例如：
```java
static final Object obj = new Object(); 

public static void m1() { 
	synchronized(obj) { 
		// 同步块 A 
		m2(); 
	} 
} 

public static void m2() { 
	synchronized(obj) { 
		// 同步块 B 
		m3(); 
	} 
} 

public static void m3() { 
	synchronized(obj) {
		// 同步块 C
	}
}
```

相当于将[[轻量级锁]]的多次锁重入的情况简化了！
![[CleanShot 2024-04-02 at 00.08.21@2x.png|300]]![[CleanShot 2024-04-02 at 00.08.38@2x.png|320]]

# [[对象头]]中的偏向状态 ———— Biased
----
无锁状态和偏向状态都是01，但是 biased_lock 标识不同！
在偏向状态下，需要存入偏向的线程id！
```java
|-------------------------------------------------------|--------------------| 
|                   Mark Word (32 bits)                 |        State       | 
|-------------------------------------------------------|--------------------| 
| hashcode:25         | age:4 | biased_lock:0    |  01  |        Normal      | 
|-------------------------------------------------------|--------------------| 
| thread:23 | epoch:2 | age:4 | biased_lock:1    |  01  |        Biased      | 
|-------------------------------------------------------|--------------------| 
```

## 加锁 🔒
将[[对象头]]置为偏向状态，thread字段指向偏向的线程id
## 解锁 🔓
处于偏向锁的对象解锁后，线程 id 仍存储于对象头中，也就是[[对象头]]不需要做任何改变
# 偏向锁的触发
---
一个对象创建时：
- 偏向锁是默认是**延迟**（4s左右）的，不会在程序启动时立即生效，这时会启用 [[轻量级锁]] or [[重量级锁]]。如果想避免延迟，可以加 VM 参数 `XX:BiasedLockingStartupDelay=`0 来禁用延迟。
- 如果没有开启偏向锁，那么对象创建后，markword 值为 0x01 即最后 3 位为 001，这时它的 hashcode、 age 都为 0，第一次用到 hashcode 时才会赋值
- 如果开启了偏向锁（默认开启），那么对象创建后，markword 值为 0x05 即最后 3 位为 101，这时它的 thread、epoch、age 都为 0 

基于[[使用jol查看Java对象头]]工具，以下进行测验：
```java
Dog dog1 = new Dog();  
//0x0000000000000001: 001-无锁，偏向锁未打开  
log.debug(ClassLayout.parseInstance(dog1).toPrintable());  
  
sleep(4);  //度过偏向锁延迟时间
  
Dog dog2 = new Dog();  
//0x0000000000000005: 101-偏向锁打开
log.debug(ClassLayout.parseInstance(dog2).toPrintable());  
```

```java
synchronized (dog1) {  
    //0x00000003093509b0: 000-轻量级锁，前面是锁记录地址  
    log.debug(ClassLayout.parseInstance(dog1).toPrintable());  
}  
//0x0000000000000001: 001-恢复无锁状态  
log.debug(ClassLayout.parseInstance(dog1).toPrintable());  
  
synchronized (dog2) {  
    //0x00007fb455009005: 101-偏向锁，前面包含线程id
    log.debug(ClassLayout.parseInstance(dog2).toPrintable());  
}  
//0x00007fb455009005：101-偏向锁，前面包含线程id
log.debug(ClassLayout.parseInstance(dog2).toPrintable());
```

# 偏向锁的撤销
----
当对象已经上了偏向锁，但是出现以下情况，偏向状态会被撤销
## 调用 hashcode()
当一个偏向状态的对象，调用了hashcode()方法，就会撤销它的偏向状态。因为[[对象头]]空间不够，偏向锁不会有额外的复制存储空间（不像，重量级锁会被复制到Monitor对象中，轻量级锁会被复制到Lock Record栈中）

代码验证：
```java
```

## 其他线程使用对象
当有其它线程使用偏向锁对象时，此时出现了竞争，会将偏向锁升级为轻量级锁

## 调用 wait/notify
还没具体学这个吧

# 优化
---
针对撤销偏向的次数，做出两种优化方式。

`偏向锁` --竞争--> `轻量级锁` --多次撤销偏向--> `重偏向锁` --多次撤销偏向--> `轻量级锁`不再偏向
## 批量重偏向
默认情况下，当有其他线程使用偏向锁对象时，会撤销偏向锁，升级为轻量级锁！
>当一个类，出现多次撤销偏向锁（因为其他线程使用该类的实例对象，升级成了轻量级锁），当撤销次数超过阈值 20 次后，JVM会修正偏向线程 ———— 将轻量级锁降为偏向锁，重新指定偏向线程。而不是像前面一样，默认升级为轻量级锁！

教程中有测试代码。
## 批量撤销
>当撤销偏向锁阈值超过 40 次后，jvm 会认为根本就不该偏向。于是该类的所有实例对象都会变为不可偏向的，新建的对象也是不可偏向的。

教程中有测试代码。