---
tags:
  - HEAD
  - "#多线程编程"
---
# 一、基本概念 🏖️
---
最基本的二元概念：[[进程与线程]]、[[并发与并行]]、[[同步与异步]]
基础：[[线程的状态]]
[[线程的活跃性问题]]

听过很多次但是不知道是啥的知识：[[守护线程]]

# 二、经典的[[线程安全]]问题 🏖️
----
有关线程安全的一些概念：
- [[临界区 Critical Section]] ———— 共享且读写
- [[竞态条件 Race Condition]] ———— 多个线程在临界区内执行

接触线程安全问题，最本质的原因就是捕捉到临界区的存在：是否在读写很好判断，而是否共享，就要基于java的语法以及JVM的内存模型来分析了 ———— [[变量的线程安全分析]]
## 问题
由于在分时系统中，各个线程是交错执行的。上下文切换的时机不对可能导致指令交错，从而产生[[多线程访问共享资源的线程安全问题]]。专业点分析这个问题就是：**在临界区中发生了竞态条件**！
## 解决方式
为了避免在临界区中产生竞态条件，有这些解决方式：
- 阻塞式的解决方案：[[Synchronized 对象锁]]、lock、[[ReentrantLock]]
- 非阻塞式的解决方案：原子变量
# 三、设计模式 🏖️
---
## 同步模式
[[保护性暂停模式(Guarded Suspension)]]
## 异步模式
[[生产者消费者模式]]
## 终止模式
[[两阶段终止模式(Two Phase Termination)]]
# 四、原理解析 🏖️
----
1. 基本原理解析
- [[线程的状态转换过程全解析]]

2. Synchronized原理解析
- 初步原理，[[重量级锁]]的底层实现：涉及到操作系统的Monitor管程
- 再了解原理细节：[[Synchronized 锁的具体实现原理]]，涉及到三种锁及各种优化

3. 基本方法的原理解析
- [[join的底层实现]]
- [[park & unpark 的底层实现]]
# 五、实战 🏖️
---
- [[如何创建线程]]
- 线程对象的方法：[[线程常见方法剖析]]
- 锁对象的方法：[[wait()与notify()]]
- 其他方法：[[park()与unpark()]]
## 工具与命令
[[linux下查看进程和线程的命令]]
[[使用jol查看Java对象头]]
# 六、思考题
---
[[泡茶]]
[[线程安全问题 ———— 超卖问题]]
[[转账问题]]
[[使用ReentrantLock解决死锁问题]]