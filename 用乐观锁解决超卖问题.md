---
tags:
  - Redis实践项目-黑马点评
  - 锁
---

# 思路
---
通过对比[[悲观锁与乐观锁]]，可以知道乐观锁的关键：**判断之前查询得到的数据是否有被修改过**。
其实现的常见方式有两种，两种方法的思想都是一样的，以超卖问题来说：
1. 版本号法
![[CleanShot 2024-03-01 at 14.37.52@2x.png]]
2. cas法
![[CleanShot 2024-03-01 at 14.38.24@2x.png]]
# 实现
---
这里实现时采用**cas**法，且只需要对 VoucherOrderServiceImpl.java 中的 `seckillVouncher`方法进行修改。
## 初步版
在扣减库存时查询，当前数据库存库存是否还和上一步取出的库存相同：
```java
// 5. 扣减库存  
boolean success = seckillVoucherService.update()   //mybatisplus给的模版写法  
        .setSql("stock = stock - 1")    //set stock = stock - 1  
        .eq("voucher_id", voucherId)  
        .eq("stock", voucher.getStock())        //where id = ? and stock = ?  
        .update();
```

但是通过测试，由于**乐观锁的问题：成功率过低**（并不是只要修改了就不能继续执行了）。这又会产生另一个问题：当200个秒杀请求并发执行，最终没卖完，只卖出了21个，很多用户秒杀失败显示库存不足。

## 改进版
解决失败率高的问题，有很多种方法：
1. 不再判断库存是否被改变，而是判断库存是否>0
2. 失败后重试，直到库存真的不足

这里继续实践第一种解决方案：
```java
// 5. 扣减库存  
boolean success = seckillVoucherService.update()   //mybatisplus给的模版写法  
        .setSql("stock = stock - 1")    //set stock = stock - 1  
        .eq("voucher_id", voucherId)  
        .gt("stock", 0)        //where id = ? and stock > ?  
        .update();
```

使用[[JMeter 工具]]测试：当200个秒杀请求并发执行，发现有100个请求成功，数据库的库存变为0，订单量为100。恰到好处的解决了超卖问题！