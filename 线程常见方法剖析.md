---
tags:
  - 多线程编程
---
以下都是 Thread 类中提供的常用方法，所以使用方式都是：
```java
threadObj.method()
```

# start()
----
>启动一个新线程，在新的线程中运行 run 方法中的代码

注意：start方法只是**让线程进入就绪状态(Runnable)**，里面代码不一定立刻运行（CPU的时间片还没分给它）。每个线程对象的start方法只能调用一次，如果调用了多次会出现 IllegalThreadStateException!
### start() vs. run()
如下，调用线程的start和run都会让线程的任务执行，但是可以通过日子输出查看到任务执行对应的线程。
**start是启动一个新线程执行，run直接在主线程调用执行**。
```java
newThread.run();  
newThread.start();
```

# sleep(long n)
---
>让当前执行的线程休眠 n 毫秒，线程从 Running运行态 进入 Timed Waiting 阻塞状态

注意：
- 其它线程可以使用 interrupt 方法打断正在睡眠的线程，这时 sleep 方法会抛出InterruptedException
- 睡眠结束后的线程未必会立刻得到执行
- 建议用 **TimeUnit.sleep()** 代替 Thread.sleep() 来获得更好的可读性：
```java
	TimeUnit.SECONDS.sleep(5);  //可以选好单位
```

### sleep() vs. yield()
两者都可以用于，**让出cpu资源**给别的线程！如果在单核cpu中，我们启动一个线程执行一个while ture循环，会让cpu一直被占用，导致空转！
- sleep：让线程从 Running运行态 进入 Timed Waiting阻塞状态
- yield：让线程从 Running运行态 进入 Runnable就绪状态

## [[wait() VS. sleep()]]
# setPriority(int p)
---
### 线程优先级
看以下源码。最大优先级为10，最小优先级是1，默认为5。
```java
public final static int MIN_PRIORITY = 1;  
public final static int NORM_PRIORITY = 5;  
public final static int MAX_PRIORITY = 10;
```

运行时其实由任务调度器具体决定每个线程分到多少时间片，不是由我们设置的绝对执行，基本在cpu较为繁忙时才会体现出差别！

# join() / join(long n)
---
>阻塞当前线程，等待某线程运行结束，最多等待 n 毫秒

## [[join的底层实现]]
底层是通过 [[wait()与notify()]] 实现的！[[wait() VS. join()]]

## 使用场景分析
根据这个例子理解：
```java
static int r = 0;  

public static void main(String[] args) throws InterruptedException {    
    Thread newThread = new Thread(() -> {  
        log.info("开始");  
        Thread.sleep(1);  
        r = 10;  
        log.info("结束");  
    });  
    
    newThread.start();  
    
    // sleep(10);  
    // newThread.join();
	
	//输出的结果大概率是0，因为主线程还没等到子线程运行到r的赋值就运行结束了！
    log.debug("结果为{}", r);  
}
```

上面代码中，如果为了在主线程拿到子线程的结果，可以使用join方法（注释掉的部分）。分析如下：
1. 如果在主线程中用sleep，不靠谱，并不确定要等多久，不好把握，pass这种思路
2. 这是一个**同步**的场景，使用jion方法
3. 其实也可以使用[[wait()与notify()]]来实现

# interrupt()
---
>改变线程的[[打断标记]]

有两种打断情况，好像都是将打断标记置为相反：
1. 打断进入了阻塞状态(如sleep，wait，join)的线程：会抛出 InterruptedException 异常，打断标记变成 `false`（清除打断标记）
2. 打断正常运行的线程：打断标记变成 `true`（不清除打断标记）

**注意：线程在何时根据打断标记改变状态（如停止or再次运行等），由线程自己决定，不一定立即改变！**

这里涉及到一种设计模式，利用interrupt终止线程：[[两阶段终止模式(Two Phase Termination)]]
## 不推荐的打断方式
有一些不推荐使用的方法，这些方法已过时，容易破坏同步代码块，造成线程死锁
- stop方法：停止线程运行
- suspend方法：挂起（暂停）线程运行
- resume()：恢复线程运行


