---
tags:
  - java
---
# 问题
---
当反序列化的类型中包含了泛型，如下：
```java
@Data  
public class RedisData<T> {  
    private LocalDateTime expireTime;  //逻辑过期时间  
    private T data;  //对应的数据，相当于本类对原数据进行一次封装  
}
```
在反序列化时，不能像往常一样，编译直接无法通过
```java
JSONUtil.toBean(shopJson, RedisData<Shop>.class);
```

# 原因
---
>当在 Java 中使用泛型时，编译器会执行**类型擦除**。

在Java中，由于类型擦除的存在，**带有泛型的类在运行时会失去具体的泛型信息**。因此，当尝试使用`.class`语法获取类的信息时，只能获取原始类型的信息，而不包括泛型参数的信息。
- 例如，对于`RedisData<Shop>`这样的泛型类，使用`RedisData<Shop>.class`是不合法的，因为在运行时只能使用`RedisData.class`。

# 解决
---
在序列化或反序列化时保留泛型信息的一种方法: 使用`TypeReference`来传递泛型信息，这是一种常见的处理泛型类型的方式。
```java
RedisData<Shop> shopRedisData = JSONUtil.toBean(  
        RedisDataJsonWithShop,  
		// 创建了一个匿名的`TypeReference`子类，以保留`RedisData<Shop>`的泛型信息
        new TypeReference<RedisData<Shop>>() {},  
        false
);
```

对于匿名子类我还不够理解，因为java这一块基本没碰。先这么理解，以上代码的意思就是：
```java
class ShopTypeReference extends TypeReference<RedisData<Shop>> {} 
RedisData<Shop> shopRedisData = JSONUtil.toBean(
		RedisDataJsonWithShop, 
		new ShopTypeReference(), 
		false
);
```

# 解决方式
---
